<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>regex</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="shortcut icon" href="/ProgressBG-Python-Slides/images/favicons/favicon-32.png">
    <!-- css & themes include -->
    <link rel="stylesheet" href="/ProgressBG-Python-Slides/lib/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="/ProgressBG-Python-Slides/outfit/css/themes/light.css" id="theme">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? '/ProgressBG-Python-Slides/lib/reveal.js/css/print/pdf.css' : '/ProgressBG-Python-Slides/lib/reveal.js/css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <!-- CUSTOM -->
    <base target="_blank">
</head>
<body>
    <div class="reveal default center" data-transition-speed="default" data-background-transition="default">
        <div class="top_links">
            <a class="home_link" href="/ProgressBG-Python-Slides/pages/agenda/agenda.html#regex" target="_top"><i class="fa fa-home"></i></a>
            <span class="help_link" href="#"><i class="fa fa-question"></i></span>
            <div class="help_text">
                <div class="note">Keyboard shortcuts:</div>
                <div><span>N/Спейс</span><span>Next Slide</span></div>
                <div><span>P</span><span>Previous Slide</span></div>
                <div><span>O</span><span>Slides Overview</span></div>
                <div><span>ctrl+left click</span><span>Zoom Element</span></div>
                <div class="print-howto"><br>If you want print version => add '<code>?print-pdf</code>' <br> at the end of slides URL (remove '#' fragment) and then print. <br>
                Like: https://wwwcourses.github.io/...CourseIntro.html?print-pdf </div>
            </div>
        </div>
        <div class="footer theme_switch">
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-Slides/outfit/css/themes/dark.css'); return false;">Dark</a>
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-Slides/outfit/css/themes/light.css'); return false;">Light</a>
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','/ProgressBG-Python-Slides/outfit/css/themes/projector.css'); return false;">Projector</a>
        </div>
        <div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section data-min-total="80"><h1>Regular Expressions in Python</h1></section>
<section data-transition="zoom">
    <!-- linkedin badge -->
    <!--<script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>-->
    <section class="copyright" data-transition="zoom">
        <div class="note">
            <p>Created for</p>
        </div>
        <div class="company">
            <a href="http://progressbg.net/програмиране-с-python-2/">
            <img style="height:80%" src="/ProgressBG-Python-Slides/outfit/images/logos/ProgressBG_logo_529_127.png">
            </a>
        </div>
        <div class="author">
            <span class="note">Iva E. Popova, 2016-2024,</span>
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
        </div>
    </section>
    <section class="copyright" data-transition="zoom" style="margin-top: -2em;">
        <div class="company">
             <div class="LI-profile-badge"  data-version="v1" data-size="large" data-locale="en_US" data-type="vertical" data-theme="dark" data-vanity="ivapopova"><a class="LI-simple-link" href='https://bg.linkedin.com/in/ivapopova?trk=profile-badge'>Iva E. Popova on LinkedIn</a></div>
        </div>
    </section>
</section>

<section data-min="20"><h1>Regular Expressions Basics</h1></section>
<section><h2>Introduction</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>Regular Expression (shortly Regex) is a <span class="note">string pattern</span>, which can match or not other strings.</dt>
            <dd>You can think of it a as a kind of search mechanism.</dd>
            <dt>Regular Expressions are coming from the <span class="note">regular language</span> defined by <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Kleene</a> in the early 1950s.</dt>
            <dt>Nowadays, almost all programming languages implements the concept of Regex.</dt>
            <dd>Also text editors (like VSCode), IDEs, Databases, CLI toos and more implements them</dd>
            <dt>Example - using regex in Python:</dt>
            <pre><code rel="Python" class="python" style="min-height: 50vh;">
                import re

                # regex that matches sequences of 8 or more word characters (letters, numbers, underscores)
                rg = re.compile(r'^\w{8,}$')

                # the string to be matched by regex:
                password = 'abc123456'

                m = rg.search(password)
                if m:
                    print(f'{password} is valid!')
                else:
                    print(f'{password} is not valid!')

                # abc123456 is valid
            </code></pre>
        </dl>
    </section>
    <section id="common-use-cases-for-regex"><h3>Common Use Cases for Regex</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>Validation</dt>
            <dd>Verify if a string matches a certain pattern, like email or phone number validation.</dd>
            <dt>Data Extraction</dt>
            <dd>Extract specific information from a text, such as extracting URLs from a webpage.</dd>
            <dt>Data Cleaning</dt>
            <dd>Remove unwanted characters or format text data according to predefined rules.</dd>
            <dt>Text Parsing</dt>
            <dd>Splitting text into tokens based on specified patterns.</dd>
        </dl>
    </section>
</section>

<section data-min="20"><h1>Regex Symbols</h1></section>
<section><h2>Regex Symbols</h2>
    <section><h3>literal and meta symbols</h3>
        <dl class="fa">
            <dt>A regex grammar includes 2 types of symbols:</dt>
            <dd><span class="note">Regular symbols</span>: they are matched literally on the matching string</dd>
            <dd><span class="note">Meta (special) characters</span>: they have special meaning and gives the power of regex</dd>
            <pre><code rel="complete list of regex metacharacters" class="python" data-noescape>
                <span style="font-size: 1.5em;line-height:1.5em;color: darkred">. ^ $ * + ? { } [ ] \ | ( )</span>
            </code></pre>
            <dd>If we want to match <b>literally</b> a meta character we have to escape it with backslash <code>'\'</code></dd>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                text = "try to match: 2+3"
                rx = re.compile('2\+3')

                res = rx.search(text)
                if res:
                    print( res.group())
            </code></pre>
        </dl>
    </section>
</section>

<section data-min="5"><h1>Character classes and sets</h1></section>
<section><h2>Character Sets</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
                <dt>The square brackets are used to define a character set. Like: <code><b>[</b>abc<b>]</b></code> (will match 'a' or 'b' or 'c').</dt>
                <dt class="note">The character set itself match only one symbol!</dt>
                <dt>Symbols inside brackets are the elements of set.</dt>
                <dt>The hyphen (<code>-</code>), when it is between 2 symbols, has special meaning inside the character class  - it defines a range. Like: <code>[0-9]</code>. If it is in the end, it is considered as a hyphen.</dt>
        </dl>
        <hr>
        <table>
            <tr><th>Character set</th><th>Description</th></tr>
            <tr><td><code class="note">[abc]</code></td><td>Match any one of the symbols listed ('a' or 'b' or 'c')</td></tr>
            <tr><td><code class="note">[a-z]</code></td><td>Match any symbol, from 'a' till 'z' (i.e. any lower Latin letter)</td></tr>
            <tr><td><code class="note">[0-9]</code></td><td>Match any digit</td></tr>
            <tr><td><code class="note">[0-9-]</code></td><td>Match any digit or hyphen</td></tr>
            <tr><td><code class="note">[^abc]</code></td><td>Match any symbol, except 'a or 'b' or 'c' (i.e. the <code><b>^</b></code> negates the characters in the set)</td></tr>
        </table>

    </section>
    <section><h3>Character Sets examples</h3>
        <pre><code rel="Python" class="python" style="min-height: 60vh;">
            import re

            # Match any vowel character
            matched = re.findall(r'[aeiouy]','astroid' );
            print(matched)
            #OUTPUT: ['a', 'o', 'i']

            # Match any non-vowel character
            matched = re.findall(r'[^aeiouy]','astroid' );
            print(matched)
            #OUTPUT: ['s', 't', 'r', 'd']

            # match any digit or hyphen:
            matched = re.findall('[0-9-]', 'a2-b8');
            print(matched)
            #OUTPUT: ['2', '-', '8']
        </code></pre>
    </section>
</section>
<section><h2>Character classes</h2>
    <section id="character-classes-definition"><h3>Overview</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>Character classes in regular expressions are shorthands for commonly used sets of characters. They provide a concise way to match specific types of characters.</dt>
            <dt>Some commonly used character classes include:</dt>
            <ul style="list-style-type: none;">
                <li><code>\d</code>: Matches any digit character (equivalent to <code>[0-9]</code>).</li>
                <li><code>\w</code>: Matches any word character (equivalent to <code>[a-zA-Z0-9_]</code>).</li>
                <li><code>\s</code>: Matches any whitespace character (spaces, tabs, newlines, etc.).</li>
                <li><code>\D</code>: Matches any non-digit character (equivalent to <code>[^0-9]</code>).</li>
                <li><code>\W</code>: Matches any non-word character (equivalent to <code>[^a-zA-Z0-9_]</code>).</li>
                <li><code>\S</code>: Matches any non-whitespace character.</li>
            </ul>
        </dl>
    </section>
    <section><h3>Character classes example</h3>
        <pre><code rel="Python" class="python" style="min-height: 85vh;">
            import re

            # Match any digit character
            text = "The price is $25.99."
            pattern = re.compile(r'\d')
            result = pattern.findall(text)
            print(result)
            # Output: ['2', '5', '9', '9']

            # Match any word character
            text = "The quick brown fox jumps over the lazy dog."
            pattern = re.compile(r'\w+')
            result = pattern.findall(text)
            print(result)
            # Output: ['The', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog']

            # Match 'line' followed by digit followed by whitespace:
            text = """line1
            line2
            line3 line4"""

            pattern = re.compile(r'line\d\s')
            result = pattern.findall(text)
            print(result)

            # Output: ['line1\n', 'line2\n', 'line3 ']
        </code></pre>
    </section>
</section>

<section data-min="5"><h1>Quantifiers</h1></section>
<section><h2>Quantifiers</h2>
    <section><h3>Overview</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>Quantifiers in regular expressions specify the quantity of the preceding element to match.</dt>
        </dl>
        <table style="font-size: .9em">
            <tr><th>Quantifier</th><th>Description</th></tr>
            <tr><td><i>r</i> <b class="note">*</b></td><td><i>r</i> match <b>0</b> or <b>more times</b></td></tr>
            <tr><td><i>r</i> <b class="note">+</b></td><td><i>r</i> match <b>1</b> or <b>more times</b></td></tr>
            <tr><td><i>r</i> <b class="note">?</b></td><td><i>r</i> match <b>0</b> or <b>1</b>time</td></tr>
            <tr><td><i>r</i> <b class="note">{n}</b></td><td><i>r</i> match <b>exactly <i>n</i> times</b></td></tr>
            <tr><td><i>r</i> <b class="note">{n,m}</b></td><td><i>r</i> match between <b>n</b> and <b>m</b> times (n, m are positive)</td></tr>
        </table>
        <p class="note"><code>r</code> can be character, group, or character class/set</p>
    </section>
    <section id="quantifiers-examples"><h3>Examples</h3>
       <dl class="fa" style="min-width:80vw">
           <dt>*</dt>
           <dd>Matches zero or more occurrences of the preceding character or group.</dd>
           <pre><code rel="Python" class="python" style="min-height: 1vh;">
               pattern = re.compile(r'ab*c')
               result = pattern.match('ac')      # Matches
               result = pattern.match('abc')     # Matches
               result = pattern.match('abbc')    # Matches
               result = pattern.match('a')       # Matches
           </code></pre>
           <dt>+</dt>
           <dd>Matches one or more occurrences of the preceding character or group.</dd>
           <pre><code rel="Python" class="python" style="min-height: 1vh;">
               pattern = re.compile(r'ab+c')
               result = pattern.match('ac')      # Doesn't match
               result = pattern.match('abc')     # Matches
               result = pattern.match('abbc')    # Matches
               result = pattern.match('a')       # Doesn't match
           </code></pre>
           <dt>?</dt>
           <dd>Matches zero or one occurrence of the preceding character or group.</dd>
           <pre><code rel="Python" class="python" style="min-height: 1vh;">
               pattern = re.compile(r'ab?c')
               result = pattern.match('ac')      # Matches
               result = pattern.match('abc')     # Matches
               result = pattern.match('abbc')    # Doesn't match
               result = pattern.match('a')       # Doesn't match
           </code></pre>
       </dl>
    </section>
    <section><h3>Examples</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>{n}</dt>
            <dd>Matches exactly <code>n</code> occurrences of the preceding character or group.</dd>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                pattern = re.compile(r'a{2}b')
                result = pattern.match('aab')     # Matches
                result = pattern.match('ab')      # Doesn't match
                result = pattern.match('aaab')    # Doesn't match
            </code></pre>
            <dt>{n,}</dt>
            <dd>Matches <code>n</code> or more occurrences of the preceding character or group.</dd>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                pattern = re.compile(r'a{2,}b')
                result = pattern.match('aab')     # Matches
                result = pattern.match('aaab')    # Matches
                result = pattern.match('ab')      # Doesn't match
            </code></pre>
            <dt>{n,m}</dt>
            <dd>Matches at least <code>n</code> and at most <code>m</code> occurrences of the preceding character or group.</dd>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                pattern = re.compile(r'a{2,3}b')
                result = pattern.match('aab')     # Matches
                result = pattern.match('aaab')    # Matches
                result = pattern.match('aaaab')   # Doesn't match
                result = pattern.match('ab')      # Doesn't match
            </code></pre>
        </dl>
    </section>
    <section><h3>Quantifiers (greedy and non-greedy match)</h3>
        <dl class="fa">
            <dt>The quantifiers are <span class="note">greedy</span>, meaning they will match the maximum part of the string they can:</dt>
            <dt>We can make them <span class="note">non-greedy</span>, if we suffix them with '<code class="note">?</code>'</dt>
            <dt>Example</dt>
            <pre><code rel="Python" class="python" style="min-height: 70vh;">
                import re

                # Greedy *
                matched = re.findall(r"a.*a", "ala bala")
                print(matched)
                # Output: ['ala bala']

                # Non-greedy *
                matched = re.findall(r"a.*?a", "ala bala")
                print(matched)
                # Output: ['ala', 'ala']

                # Greedy {n,m}
                matched = re.findall(r"\d{2,4}", "123456789")
                print(matched)
                # Output: ['1234', '5678']

                # Non-greedy {n,m}
                matched = re.findall(r"\d{2,4}?", "123456789")
                print(matched)
                # Output: ['12', '34', '56', '78']

            </code></pre>
        </dl>
    </section>
</section>

<section data-min="5"><h1>Anchors and Boundaries</h1></section>
<section><h2>Anchors and Boundaries</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>They specify a <b>position</b> in the string where a match should occurs.</dt>
            <dt>They are zero-width, i.e.when matched they do NOT consume characters from the string.</dt>
        </dl>
        <table style="font-size: .9em">
            <tr><th>Anchor</th><th>Description</th></tr>
            <tr><td class="note">^</td><td>Matches the <span class="note">beginning</span> of the string (or the line, if <b>m</b> flag is used)</td></tr>
            <tr><td class="note">$</td><td>Matches the <span class="note">end</span> of the string (or the line, if <b>m</b> flag is used)</td></tr>
            <tr><td class="note">\b</td><td>Matches on word boundaries, i.e. between <i>word</i>(\w) and <i>non-word</i>(\W) characters.<br>Note that the <b>start</b> and <b>end</b> of string are considered as non-word characters.</td></tr>
            <tr><td class="note">\Z</td><td>Matches only at the end of the string.</td></tr>
        </table>
    </section>
    <section><h3><code>^</code> and <code>$</code> example</h3>
        <pre><code rel="Python" class="python" style="min-height: 50vh;">
            import re

            strings = [
                'ana',
                'ana bel',
            ]
            rx = re.compile(r'^a.+a$');

            for string in strings:
                res = rx.findall(string)
                print("{} matches in {}".format(len(res), string))

            #Output:
            #1 matches in ana
            #0 matches in ana bel
        </code></pre>
    </section>
    <section><h3><code>\b</code> example</h3>
        <pre><code rel="Python" class="python" style="min-height: 78vh;">
            import re

            strings = [
                '',
                'a',
                '@',
                '@a',
                'aa',
                'a!',
                'a,a',
            ]
            rx = re.compile(r'\b');

            for string in strings:
                res = rx.findall(string)
                print(f"{len(res)} word bounders counted in {string}")


            # 0 word bounders counted in
            # 2 word bounders counted in a
            # 0 word bounders counted in @
            # 2 word bounders counted in @a
            # 2 word bounders counted in aa
            # 2 word bounders counted in a!
            # 4 word bounders counted in a,a
        </code></pre>
    </section>
</section>

<section data-min="5"><h1>Modifiers/Flags</h1></section>
<section><h2>Modifiers/Flags</h2>
    <section><h3>Modifiers/Flags</h3>
        <dl class="fa">
            <dt>Flags reflects how the regular expression is executed.</dt>
            <dt>They are available in the re module with a long name such as <code>re.IGNORECASE</code> or with a short, one-letter form such as <code>re.I</code>.</dt>
            <dt>Multiple flags can be specified by bitwise OR-ing them. For example <code>re.I|re.M</code> sets both the I and M flags.</dt>
            <dt>Flags can be set as second argument to the re.compile() method</dt>
            <pre><code rel="Python" class="python">
                regex_with_flags_arg = re.compile(r"[aeiouy]+",re.I)
            </code></pre>
            <dt>Or as a third argument on re module methods</dt>
            <pre><code rel="Python" class="python">
                m = re.search(r"[aeiouy]+", str, re.I)
            </code></pre>
            <dt>Flags can be also set in the regular expression itself, using (?aiLmsux) syntax at the beginning of the regex string</dt>
            <pre><code rel="Terminal" class="bash">
                regex_with_flags_prefix= re.compile(r"(?i)[aeiouy]+")
            </code></pre>
        </dl>
    </section>
    <section><h3>Modifiers/Flags list</h3>
        <table>
            <tr><th>In reges</th><th>As param</th><th>Description</th></tr>
            <tr><td>(?i)</td><td>re.I</td><td>case-<b>i</b>nsensitive matching</td></tr>
            <tr><td>(?m)</td><td>re.M</td><td><b>m</b>ultiline matching</td></tr>
            <tr><td>(?s)</td><td>re.S</td><td>Make the '<b>.</b>' to match any character at all, including a newline</td></tr>
            <tr><td>(?x)</td><td>re.X</td><td>Allows to write readable regexes by using spaces and comments('#') in the regex. More on: <a href="https://docs.python.org/3/library/re.html#re.X">re.X</a></td></tr>
        </table>
        <p>Reference: <a href="https://docs.python.org/3/howto/regex.html#compilation-flags">Compilation flags</a></p>
    </section>
    <section><h3>Modifiers/Flags example</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>Using the re.IGNORECASE flag to perform case-insensitive matching</dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                text = "The quick brown fox jumps over the lazy dog."

                pattern = re.compile(r"the", flags=re.IGNORECASE)
                result = pattern.findall(text)


                # Output:
                # ['The', 'the']
            </code></pre>
            <dt>Using re.MULTILINE flag to match at beginning of each line:</dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                # Example text containing multiple lines
                text = """Line 1
                # Line 2
                Line 3"""

                # Matching lines starting with "Line"
                pattern = re.compile(r'^Line\s*\d', re.MULTILINE)
                result = pattern.findall(text)
                print(result)

                # Output: ['Line 1', 'Line 3']
            </code></pre>
        </dl>
    </section>
</section>

<section data-min="5" class="main-section-title"><h1>Alternation</h1></section>
<section class="sub-sections"><h2>Alternation</h2>
    <section><h3>Alternation</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>Alternation allows you to match one pattern or another. It is denoted by the pipe symbol <code>|</code>.</dt>
            <pre><code rel="Python" class="python">
                import re

                text = "I love cats. He love dogs."
                pattern = re.compile(r"cat|dog")

                result = pattern.findall(text)
                print(result)

                # Output: ['cat', 'dog']
            </code></pre>
            <dt>The alternation operator has the lowest precedence of all regex operators. That is, it tells the regex engine to match either everything to the left of pipe, or everything to the right of pipe.</dt>
            <dd>If you want to limit the reach of the alternation, you need to use parentheses for grouping (discussed in next topic).</dd>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                text = "I love cats. He love dogs."
                pattern = re.compile(r"(?:cat|dog)s")

                result = pattern.findall(text)
                print(result)
            </code></pre>
        </dl>
    </section>
</section>

<section data-min="5"><h1>Grouping and capturing</h1></section>
<section><h2>Grouping and capturing</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>Brackets: <span class="note">(</span> and <span class="note">)</span>, play a dual role in regex!</dt>
            <dt>They can be used to <span class="note">capturing groups</span>, to remember a matched part of the string. Like: </dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                text = "Ivan Ivanov: 30 years old, Petar Petrov: 25 years old"

                # Using capturing group to get names and ages
                pattern = re.compile(r"(\w+ \w+): (\d+) years old")
                matches = pattern.findall(text)

                for match in matches:
                    print("Name:", match[0])
                    print("Age:", match[1])
            </code></pre>
            <dt>Brackets can be used for <span class="note">non-capturing groups</span> to group parts in a regex without capturing: </dt>
            <dd><code><b>/(?:r1|r2)r3/</b></code> => match <code><b>r1r3</b></code> OR <code><b>r2r3</b></code>, but not <code><b>r1r2r3</b></code></dd>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                # Example text
                text = "I love strawberries and raspberries, but not blueberries."

                # Using non-capturing group with alternation to match "quick" or "lazy"
                pattern = re.compile(r"(?:straw|rasp)berries")
                result = pattern.findall(text)
                print(result)
                # Output: ['strawberries', 'raspberries']
            </code></pre>
            <dt class="note">NB! Capturing is slow and memory consuming! If you need the parenthesis just for grouping- always use the <b>?:</b> prefix.</dt class="note">
        </dl>
    </section>
</section>


<section data-min="20"><h1>Using regex in Python - the <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module</h1></section>
<section><h2>Using regex in Python - the <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>The built-in <code><a href="https://docs.python.org/3/library/re.html">re</a></code> module in Python provides regular expression matching operations similar to those found in Perl.</dt>
            <dt>Regular expressions are compiled into <a href="https://docs.python.org/3/library/re.html#re-objects">Regular Expression Object</a>, which have methods for various operations such as searching for pattern matches or performing string substitutions.</dt>
            <dt>REs in Python are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them.</dt>
        </dl>
    </section>
    <section><h3>How to write regex</h3>
        <dl class="fa">
            <dt>Regex in Python are written as string, which can be passed to re.compile() method or directly to other matching methods, like re.search(), re.match()</dt>
            <dt>We can use any string literals, including the <a href="https://docs.python.org/2/reference/lexical_analysis.html#index-17">raw string</a> syntax (<code>r''</code> ) </dt>
            <dt>Example of raw string:</dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                print('\test')      #        est
                print(r'\test')     #\test
                print('\\test')     #\test
            </code></pre>
        </dl>
    </section>
    <section><h3>the <code><a href="https://docs.python.org/3/library/re.html#re.compile">re.compile()</a></code> method</h3>
        <dl class="fa">
            <dt>Compiles a regular expression pattern into a regular expression object, which can be used for matching using its methods for matching and search</dt>
        </dl>
        <pre><code rel="Python" class="python" style="min-height: 1vh;">
            import re

            text = "ABRACADABRA"

            regex = re.compile(r'aca', re.I)

            if regex.search(text):
                print('Match')
        </code></pre>
    </section>
</section>

<section data-min="20"><h1>Regular Expression Objects Methods</h1></section>
<section><h2>Regular Expression Objects Methods</h2>
    <section><h3><a href="https://docs.python.org/3/library/re.html#re.Pattern.search">regex.search(string[, start[, end]]))</a></h3>
        <dl class="fa">
            <dt>Scan through string looking for the  where this regular expression produces a match.</dt>
            <dt>If match produced => returns a corresponding <a href="https://docs.python.org/3/library/re.html#match-objects">match object</a></dt>
            <dt>If string does not matches the pattern => return <span class="note">None</span></dt>
            <dt>optional parameters:</dt>
            <dd><i>start</i> - the index where the search should start</dd>
            <dd><i>end</i> - the index where the search should ends</dd>
            <dt>Example: </dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                import re

                text = "123abc456"
                rx = re.compile('abc')

                res = rx.search(text) # will match
                res = rx.search(text,3) # will match, 'a' is on index 3 in text
                res = rx.search(text,4) # would NOT match
            </code></pre>
        </dl>
    </section>
    <section><h3><a href="https://docs.python.org/3/library/re.html#re.Pattern.match">regex.match(string[, start[, end]])</a></h3>
        <dl class="fa">
            <dt>Matches only <span class="note">on the beginning of the string</span></dt>
            <dt>If you want to locate a match anywhere in string, use search() instead</dt>
            <dt>Reference: <a href="https://docs.python.org/3/library/re.html#search-vs-match">search-vs-match @python docs</a></dt>
            <dt>Example:</dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                text = "123abc456"
                rx = re.compile('abc')

                res = rx.match(text)

                res = rx.match(text) # will NOT match, 'abc' is not in the beginning
                res = rx.match(text,3) # will match, as matching starts from index 3
            </code></pre>
        </dl>
    </section>
    <section><h3><a href="https://docs.python.org/3/library/re.html#re.Pattern.findall">regex.findall(string[, pos[, endpos]])</a></h3>
        <dl class="fa">
            <dt>Returns <span class="note"> a list of strings</span> containing all non-overlapping matches of regex in the string</dt>
            <dt>The string is scanned left-to-right, and matches are returned in the order found</dt>
            <dt>Example:</dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                text = "123abc456abcabc"
                rx = re.compile('abc')

                res = rx.findall(text) # ['abc', 'abc', 'abc']
                res = rx.findall(\dtext) # ['3abc', '6abc']
            </code></pre>
        </dl>
    </section>
    <section><h3>Other Matching Methods</h3>
        <dl class="fa">
            <dt><a href="https://docs.python.org/3/library/re.html#re.Pattern.finditer">regex.finditer(string[, pos[, endpos]])</a></dt>
            <dt><a href="https://docs.python.org/3/library/re.html#re.Pattern.fullmatch">regex.fullmatch(string[, pos[, endpos]])</a></dt>
            <dt><a href="https://docs.python.org/3/library/re.html#re.Pattern.sub">regex.sub(repl, string, count=0)</a></dt>
            <dt><a href="https://docs.python.org/3/library/re.html#re.Pattern.subn">regex.subn(repl, string, count=0)</a></dt>
        </dl>
    </section>
    <section><h3>re module-level functions</h3>
        <dl class="fa">
            <dt>The methods described above, was methods of an Regular Expression Objects</dt>
            <dt>Python has similar functionality defined in the <code>re</code>  module, like:</dt>
            <dd><a href="https://docs.python.org/3/library/re.html#re.search">re.search(pattern, string, flags=0)</a></dd>
            <dd><a href="https://docs.python.org/3/library/re.html#re.match">re.match(pattern, string, flags=0)</a></dd>
            <dd>and so on...</dd>
            <dt>The difference is that we must pass the pattern string as first argument, and optional flags at the end.</dt>
        </dl>
    </section>
</section>

<section data-min="5"><h1>The Match Object</h1></section>
<section><h2><a href="https://docs.python.org/3/library/re.html#match-objects">The Match Object</a></h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>match() and search() methods returns a <a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> or None</dt>
            <dt>So you can test whether there was a match with a simple if statement:</dt>
            <pre><code rel="Python" class="python" style="min-height: 1vh;">
                match = re.search(pattern, string)
                if match:
                    process(match)
            </code></pre>
        </dl>
    </section>
    <section><h3><a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> Methods</h3>
        <table style="width: 110%">
            <tr><th>Method/Attribute</th><th>Purpose</th></tr>
            <tr><td>group()</td><td>Return the string matched by the RE</td></tr>
            <tr><td>groups()</td><td>Return a tuple containing all the subgroups of the match</td></tr>
            <tr><td>start()</td><td>Return the starting position of the match</td></tr>
            <tr><td>end()</td><td>Return the ending position of the match</td></tr>
            <tr><td>span()</td><td>Return a tuple containing the (start, end) positions of the match</td></tr>
        </table>
        <p>More methods: <a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a></p>
    </section>
    <section><h3><a href="https://docs.python.org/3/library/re.html#match-objects">Match Object</a> Methods - example</h3>
        <pre><code rel="Python" class="python" style="min-height: 1vh;">
            text = "123abc456abc"
            rx = re.compile('(\d+)(abc)')

            res = rx.match(text)
            if res:
                print("res.group():", res.group()) #123abc
                print("res.groups():", res.groups()) #('123', 'abc')
            else:
                print("No match!")
        </code></pre>
    </section>
</section>

<section class="main-section-title"><h1>Examples</h1></section>
<section class="sub-sections"><h2>Examples</h2>
    <section><h3>Validate Bulgarian mobile number</h3>
        <pre><code rel="Python" class="python" style="min-height: 101vh;">
            import re

            def is_valid_bg_mobile_number(number):
                """ Validates a Bulgarian mobile number.
                    Note:
                        The format of a valid Bulgarian mobile number is: +359 XX XDDD DDD,
                        where X is in [7, 8, 9], and D is in [0-9].
                    Args:
                        number (str): The mobile number to be validated.

                    Returns:
                        bool: True if the number is a valid Bulgarian mobile number, False otherwise.
                """
                rg = re.compile(r'^\+359\s[7-9]{2}\s[7-9]\d{3}\s\d{3}$')

                m = rg.match(number)

                return True if m else False


            if __name__=="__main__":
                phone_numbers = [
                    '+359 88 7123 456', #yes
                    '+359 88 7123456',  #no
                    '+359 88 1123 456', #no
                    '+359 87 9123 456'  #yes
                ]

                for number in phone_numbers:
                    if is_valid_bg_mobile_number(number):
                        print(f'{number:18} #yes')
                    else:
                        print(f'{number:18} #no')
        </code></pre>
    </section>
    <section><h3>Validate user name</h3>
        <pre><code rel="Python" class="python" style="min-height: 100vh;">
            import re

            def is_valid_user_name(number):
                """ Validates a User name.

                    Note:
                        User name must follow next rules:
                            1. Must consists of 3 to 10 characters inclusive.
                            2. Username can only contain alphanumeric characters, dashes (-) and underscores (_).
                            3. The first character of the username must be an alphabetic character

                    Args:
                        number (str): The user name to be validated.

                    Returns:
                        bool: True if the name is a valid, False otherwise.
                """
                rg = re.compile(r'''
                ^					# beginning of string
                    [a-zA-Z]  		# rule 3
                    [\w-]{2,9}		# rule 1 and 2
                $					# end of string
                ''', re.VERBOSE)
                m = rg.match(number)

                return True if m else False


            if __name__=="__main__":
                user_names = [
                    "ada", 	        # yes
                    "a__", 	        # yes
                    "a12345",       # yes
                    "a1234567890",  # no (rule 1)
                    "1aaaaaaa",     # no (rule 3)
                    "aaa#", 	    # no (rule 2)
                    "a", 		    # no (rule 1)
                ]

                for user_name in user_names:
                    if is_valid_user_name(user_name):
                        print(f'{user_name:18} #yes')
                    else:
                        print(f'{user_name:18} #no')
        </code></pre>
    </section>
</section>

<section data-min="5" class="main-section-title"><h1>Resources</h1></section>
<section class="sub-sections"><h2>Resources</h2>
	<!-- <section><h3>Video</h3>
		<p>Reg(exp){2}lained/: Demystifying Regular Expressions by Lea Verou</p>
		<iframe width="767" height="431" src="https://www.youtube.com/embed/EkluES9Rvak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
	</section> -->
	<section><h3>Online Regex Testers and Cheet-sheet</h3>
		<dl class="fa">
			<dt><a href="https://www.debuggex.com/cheatsheet/regex/python">Python Regex Cheatsheet</a></dt>
			<dt><a href="https://regex101.com/">regex101.com - Online regex tester and debugger: PHP, PCRE, Python, Golang ...</a></dt>
		</dl>
	</section>
	<section><h3>regex Excersises</h3>
		<dl class="fa">
			<dt><a href="https://regex101.com/quiz">regex101 regex quiz</a></dt>
			<dt><a href="https://regexone.com/">regexone.com</a> - Learn Regular Expressions with simple, interactive exercises.</dt>
		</dl>
	</section>
</section>


<section class="disclaimer" data-background="/ProgressBG-Python-Slides/outfit/images/for_slides/the_end_on_sand.jpg">
     <p>These slides are based on</p>
     <p>customised version of </p>
     <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
     <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
        </div>
    </div>
    <!-- Custom processing -->
    <script src="/ProgressBG-Python-Slides/outfit/js/slides.js"></script>
    <!-- external scripts -->
    <script src="/ProgressBG-Python-Slides/lib/reveal.js/lib/js/head.min.js"></script>
    <script src="/ProgressBG-Python-Slides/lib/reveal.js/js/reveal.js"></script>
     <!-- init reveal -->
    <script>
        // Full list of configuration options available at:
        // https://github.com/hakimel/reveal.js#configuration
        var highlightjsTabSize = '  ';
        Reveal.initialize({
            controls: true,
            progress: true,
            slideNumber: 'c/t',
            keyboard: true,
            history: true,
            center: true,
            width: 1920,
            height: 1280,
            // Bounds for smallest/largest possible scale to apply to content
            // minScale: .5,
            maxScale: 1,
            // slide transition
            transition: 'concave', // none/fade/slide/convex/concave/zoom
            // Factor of the display size that should remain empty around the content
            margin: 0.1,
            // shift+maous click to zoom in/out element
            zoomKey: 'ctrl',
            // theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
            // transition: Reveal.getQueryHash().transition || 'default'
            // Optional reveal.js plugins
            dependencies: [
                { src: '/ProgressBG-Python-Slides/lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: '/ProgressBG-Python-Slides/lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: '/ProgressBG-Python-Slides/lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: '/ProgressBG-Python-Slides/lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure(); hljs.initHighlightingOnLoad(); } },
                { src: '/ProgressBG-Python-Slides/lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
                { src: '/ProgressBG-Python-Slides/lib/reveal.js/plugin/notes/notes.js', async: true }
            ]
        });
    </script>
</body>
</html>
